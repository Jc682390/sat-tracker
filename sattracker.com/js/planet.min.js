var satfixes = new Array;
var classify = new Array;
var last_fetched = 0;
var is_fetching = false;
var offset = 0;
var myloc = [];
var satfile = "/json/starpos.json";
var groundfile = "/json/basestations.json";
var hexesfile = null;
var hexesfile1 = null;
var hexesfile2 = null;
var classifyfile = "/json/classify.json";
var grounddata;
var ppp;
var selected = new Object;
var tryct = 0;
const sig = "v1007+" + Math.floor(Math.random() * 1e5);
const urlParams = new URLSearchParams(window.location.search);
var isQp = urlParams.get("norad") !== null;
var norad = isQp ? parseInt(urlParams.get("norad")) : null;
try {
    var name = document.getElementById("quakejs").getAttribute("data-satfile");
    satfile = name;
    if (name == "/json/sl.json") {
        groundfile = "/json/basestations.json";
        classifyfile = "/json/classify.json";
        stampfile = "/json/starpos_servertime.json";
        hexesfile = "/json/footprint.json";
        hexesfile1 = "/json/coverage.json";
        hexesfile2 = "/json/peeps.json"
    } else {
        groundfile = null;
        classifyfile = null;
        hexesfile = null;
        hexesfile1 = null;
        stampfile = satfile
    }
} catch (err) {
    console.log(err)
}
try {
    var s = window.localStorage.getItem("myloc");
    if (s) {
        myloc = JSON.parse(s)
    }
} catch (err) {
    console.error("failed to get mylocation", err)
}
function unsel_norad(i) {
    selected = new Object;
    const url = new URL(window.location);
    url.searchParams.delete("norad");
    window.history.pushState({}, document.title = "Live Starlink Satellite Map", url);
    isQp = null;
    norad = null
}
function sel_norad(i, oname) {
    if (window.history.replaceState) {
        const url = new URL(window.location);
        url.searchParams.set("norad", i);
        window.history.pushState({}, document.title = "NORAD object " + i + " " + oname + " position", url)
    }
}
function julofyear(date) {
    return (Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()) - Date.UTC(date.getFullYear(), 0, 0)) / 24 / 60 / 60 / 1e3
}
function calcOffset() {
    var xmlhttp = new XMLHttpRequest;
    xmlhttp.open("HEAD", stampfile + "?" + Math.random(), true);
    xmlhttp.onload = function(e) {
        if (xmlhttp.readyState === 4) {
            var dateStr = xmlhttp.getResponseHeader("Date");
            var serverTimeMillisGMT = Date.parse(new Date(Date.parse(dateStr)).toUTCString());
            var localMillisUTC = Date.parse((new Date).toUTCString());
            offset = (serverTimeMillisGMT - localMillisUTC) / 1e3;
            if (offset)
                console.log("local to server time offset = " + offset + "s")
        }
    }
    ;
    xmlhttp.send(null)
}
function loadDict() {
    if (classifyfile)
        d3.json(classifyfile + "?" + Math.random(), function(err, data) {
            if (err) {
                console.error(err);
                return
            }
            for (var i = 0; i < data.classify.length; i++) {
                var o = new Object;
                o.orbit = data.classify[i].orbit;
                o.doing = data.classify[i].doing;
                classify[data.classify[i].sat] = o
            }
        })
}
loadDict();
calcOffset();
function zoom_to_qp(planet) {
    if (norad) {
        for (var x = 0; x < showingsats.length; x++) {
            if (showingsats[x].id == norad) {
                select_unselect(planet, x);
                planet.plugins.myloc.gospot(planet, showingsats[x].lng, showingsats[x].lat);
                return
            }
        }
    }
}
function isItNumber(str) {
    return /^\-?[0-9]+(e[0-9]+)?(\.[0-9]+)?$/.test(str)
}
async function calc_passes(norad, title) {
    if (settings && settings.myloc.length == 2 && isItNumber(settings.myloc[0]) && isItNumber(settings.myloc[1])) {
        await d3.json("/api/passes?norad=" + norad + "&lat=" + settings.myloc[0] + "&lng=" + settings.myloc[1], function(err, data) {
            var html = "";
            if (data.data.passes.length == 0) {
                html = "<i>No close passes found over the next 3 days</i>"
            } else {
                html = "<span style='font-size:0.9em'><table><caption style='caption-side:bottom'>projected passes</caption>";
                html += "<tr><th>Local Time</th><th>Light</th><th>Bearing</th><th>Dur.</th></tr>";
                for (var x = 0; x < data.data.passes.length; x++) {
                    var p = data.data.passes[x];
                    var t = new Date(p.utcpass);
                    var bg = p.view != "night" && p.view != "day" ? 'style = "background-color:#cfc"' : "";
                    var s = t.toLocaleString().replace("/2021", "");
                    html += "<tr " + bg + "><td align=center>" + s + "</td>" + "<td align=center>" + p.view + "</td>" + "<td align=center>" + p.elazf[1] + "&rarr;" + p.elazt[1] + "</td>" + "<td align=center>" + p.duration_mins + " mins</td>" + "</tr>"
                }
                html += "</table></span>"
            }
            modal_content(title, html)
        })
    } else {
        myalert("Please set your home location in Settings")
    }
}
function select_unselect(planet, i) {
    var julian = julofyear(new Date);
    if (i != null && selected[i] == undefined) {
        var d = showingsats[i];
        var html = "<pre class='pre-tabbed' style='tab-size:8; font-family:\"open sans\"'>";
        if (d.alt == 0) {
            html += "name: " + d.name + "<br/>" + "norad: " + d.id + "<br/>" + "de-orbit"
        } else {
            if (d.oname == "ISS" || d.oname == "CSS") {
                html += "Space Station (" + d.oname + ")<br/>"
            } else {
                html += "launch&#09; " + (d.l ? d.l.utc : "?") + "<br/>" + "sat ver.&#09; " + (d.l ? d.l.satver : "?") + "<br/>"
            }
            html += "name&#09; " + d.oname + "<br/>" + "norad&#09; " + d.id + "<br/>" + "altitude&#09; " + d.alt + "km<br/>" + "plane&#09; " + Math.floor(d.raan * 10) / 10 + "°<br/>" + (classify.length && classify[d.id] ? "state&#09; " + classify[d.id].orbit + "<br/>" + "actvity&#09; " + classify[d.id].doing + "<br/>" : "");
            html += "TLE&#09;&#09; " + d.age + "d old<br/>";
            html += "Passes&#09;<button style='background-color:#cfc' onclick='calc_passes(" + d.id + "," + '"' + d.oname + '"' + "); return false'>calculate</button>"
        }
        html += "</pre>";
        modal_content("NORAD " + d.id, html);
        graphAlt(d.id);
        selected[i] = true;
        planet.plugins.pings.sel(i, planet, true);
        sel_norad(d.id, d.oname)
    } else {
        planet.plugins.pings.unsel(i, planet);
        unsel_norad();
        graphAltOff()
    }
}
function ignoresat(ping) {
    var ign = 0;
    if (ping.id == 48274 || ping.id == 25544)
        return 0;
    if (settings && settings.show == "faults") {
        if (classify && classify.length && classify[ping.id]) {
            if (classify[ping.id].doing.substring(0, 6) == "rising") {
                ign = 1
            }
            if (classify[ping.id].doing.substring(0, 7) != "sinking") {
                if (classify[ping.id].orbit == "service" || classify[ping.id].orbit == "parked" || classify[ping.id].orbit == "high") {
                    ign = 2
                }
            }
        }
    }
    if (classify && classify.length) {
        if (settings && settings.show == "active") {
            if (!classify[ping.id] || classify[ping.id].orbit != "service") {
                ign = 3
            }
        }
        if (settings && settings.show == "stored") {
            if (!classify[ping.id] || classify[ping.id].orbit != "parked") {
                ign = 4
            }
        }
        if (settings && settings.show == "declining") {
            if (!classify[ping.id] || classify[ping.id].doing.substring(0, 7) != "sinking") {
                ign = 5
            }
        }
        if (settings && settings.show == "rising") {
            if (!classify[ping.id] || classify[ping.id].doing.substring(0, 6) != "rising") {
                ign = 6
            }
        }
    }
    if (settings && settings.of.match(/^\d+$/) && settings.tf.match(/\d+$/) && parseInt(settings.tf) > parseInt(settings.of)) {
        if (ping.raan && (ping.raan < parseInt(settings.of) || ping.raan > parseInt(settings.tf))) {
            ign = 7
        }
    }
    if (settings && settings.satver && settings.satver != "all") {
        var l = ppp.plugins.pings.p2l(ping);
        if (l) {
            var lok = settings.satver.toLowerCase().split(",");
            var ok = 0;
            for (var xx = 0; xx < lok.length; xx++) {
                if (l.satver.includes(lok[xx]))
                    ok++
            }
            if (!ok)
                ign = 10
        }
    }
    if (settings && settings.launch && settings.launch != "all") {
        var l = parseInt(ping.name.split("-")[0]);
        var lok = settings.launch.split(",");
        var ok = 0;
        for (var xx = 0; xx < lok.length; xx++) {
            lok2 = lok[xx].split("-");
            if (lok2.length > 1) {
                if (l >= parseInt(lok2[0]) && l <= parseInt(lok2[1]))
                    ok++
            } else if (lok2[0].match(/^[0-9]+$/) && parseInt(lok2[0]) == l)
                ok++
        }
        if (!ok)
            ign = 9
    }
    return ign
}
function graphAltOff() {
    document.getElementById("myDiv").style.display = "none"
}
function loadScript(url, callback) {
    var script = document.createElement("script");
    script.type = "text/javascript";
    if (script.readyState) {
        script.onreadystatechange = function() {
            if (script.readyState == "loaded" || script.readyState == "complete") {
                script.onreadystatechange = null;
                callback()
            }
        }
    } else {
        script.onload = function() {
            callback()
        }
    }
    script.src = url;
    document.getElementsByTagName("head")[0].appendChild(script)
}
function graphAlt(norad) {
    if (typeof Plotly === "undefined") {
        loadScript("js/lib/plotly-cartesian-latest.min.js", function() {
            _graphAlt(norad)
        })
    } else {
        _graphAlt(norad)
    }
}
function _graphAlt(norad) {
    d3.json("/json/" + norad + ".json?" + Math.random(), function(err, data) {
        if (err) {
            return
        }
        var x = [];
        var y = [];
        for (var i = 0; i < data.fixes.length; i++) {
            x.push(-data.fixes[i].days);
            y.push(data.fixes[i].alt)
        }
        var trace1 = {
            x: x,
            y: y,
            type: "scatter"
        };
        var data = [trace1];
        var layout = {
            titlefont: {
                size: 9
            },
            title: "Altitude history of <a target=_top href='https://www.n2yo.com/satellite/?s=" + norad + "'><span style='color:yellow'>Norad ID " + norad + "</span></a>",
            paper_bgcolor: "#202020",
            plot_bgcolor: "#202020",
            font: {
                color: "white"
            },
            margin: {
                l: 50,
                t: 30,
                b: 30,
                r: 10,
                pad: 0
            },
            xaxis: {
                title: {
                    text: "days past",
                    font: {
                        size: 8
                    }
                }
            },
            yaxis: {
                title: {
                    text: "altitude (km)",
                    font: {
                        size: 8
                    }
                }
            }
        };
        document.getElementById("myDiv").style.display = "";
        document.getElementById("myDiv").innerHTML = '<div class="c-button c-button-vsm" style="position:absolute; z-index:999; right:5px; top: 2px;" onclick="document.getElementById(\'myDiv\').style.display=\'none\'; return false">X</div>';
        Plotly.newPlot("myDiv", data, layout, {
            responsive: true,
            modeBarButtonsToRemove: ["zoom2d", "pan2d", "select2d", "lasso2d", "zoomIn2d", "zoomOut2d", "autoScale2d", "resetScale2d", "toggleSpikelines", "toImage", "toggleHover", "hoverClosestCartesian", "hoverCompareCartesian"],
            displaylogo: false
        })
    })
}
function getrandom(num, mul) {
    var value = [];
    for (i = 0; i <= num; i++) {
        var rand = Math.random() * mul;
        value.push(rand)
    }
    return value
}
function graphConClose() {
    document.getElementById("myDiv1").style.display = "none"
}
function graphCon() {
    if (typeof Plotly === "undefined") {
        loadScript("js/lib/plotly-cartesian-latest.min.js", function() {
            _graphCon()
        })
    } else {
        _graphCon()
    }
}
function graphStatus() {
    if (typeof Plotly === "undefined") {
        loadScript("js/lib/plotly-cartesian-latest.min.js", function() {
            _graphStatus()
        })
    } else {
        _graphStatus()
    }
}
function _graphStatus() {
    d3.json("/json/status.json?" + Math.random(), function(err, data) {
        if (err) {
            myalert("unable to get constellation status");
            console.error(err);
            return
        }
        var trace1 = {
            x: [],
            y: [],
            name: "Total",
            type: "line",
            line: {
                color: "white"
            }
        };
        var trace2 = {
            x: [],
            y: [],
            name: "Service",
            type: "line",
            line: {
                color: "green"
            }
        };
        var trace3 = {
            x: [],
            y: [],
            name: "Burned",
            type: "line",
            line: {
                color: "red"
            }
        };
        var trace4 = {
            x: [],
            y: [],
            name: "Inactive",
            type: "line",
            line: {
                color: "yellow"
            }
        };
        for (var x = 0; x < data.starlink.length; x++) {
            trace1.x.push(data.starlink[x].date);
            trace2.x.push(data.starlink[x].date);
            trace3.x.push(data.starlink[x].date);
            trace4.x.push(data.starlink[x].date);
            trace1.y.push(data.starlink[x].total);
            trace2.y.push(data.starlink[x].service);
            trace3.y.push(data.starlink[x].burn);
            trace4.y.push(data.starlink[x].total - data.starlink[x].service - data.starlink[x].burn)
        }
        var data = [trace1, trace2, trace3, trace4];
        var layout = {
            margin: {
                l: 80,
                t: 50,
                b: 50,
                r: 10,
                pad: 0
            },
            title: "Constellation size over time",
            paper_bgcolor: "#202020",
            plot_bgcolor: "#202020",
            font: {
                color: "white"
            },
            xaxis: {
                tickfont: {
                    size: 14,
                    color: "rgb(107, 107, 107)"
                }
            },
            yaxis: {
                title: "Total",
                titlefont: {
                    size: 16,
                    color: "rgb(107, 107, 107)"
                },
                tickfont: {
                    size: 14,
                    color: "rgb(107, 107, 107)"
                }
            },
            legend: {
                x: 0,
                y: 1,
                _bgcolor: "rgba(255, 255, 255, 0)",
                _bordercolor: "rgba(255, 255, 255, 0)"
            },
            barmode: "group",
            bargap: .15,
            bargroupgap: .1
        };
        Plotly.newPlot("myDiv1", data, layout, {
            responsive: true,
            modeBarButtonsToRemove: ["zoom2d", "pan2d", "select2d", "lasso2d", "zoomIn2d", "zoomOut2d", "resetScale2d", "toggleSpikelines", "toImage", "toggleHover", "hoverClosestCartesian", "hoverCompareCartesian"],
            displaylogo: false
        });
        document.getElementById("myDiv1").style.display = ""
    })
}
function _graphCon() {
    d3.json("/json/constellation.json?" + Math.random(), function(err, data) {
        if (err) {
            alert("unable to get constellation structure");
            console.error(err);
            return
        }
        var xx = new Array;
        var yy = new Array;
        var zz = new Array;
        var tt = new Array;
        for (var x = 0; x < data.data.length; x++) {
            xx.push(data.data[x].an);
            yy.push(data.data[x].ap);
            zz.push(data.data[x].alt);
            tt.push(data.data[x].norad + " " + data.data[x].alt + "km")
        }
        var cnt = data.data.length;
        var data = [{
            type: "scatter",
            x: xx,
            y: yy,
            z: zz,
            text: tt,
            mode: "markers",
            marker: {
                size: 3,
                color: "rgba(0,255,0,1)",
                opacity: 1
            },
            hoverinfo: "text"
        }];
        var layout = {
            hovermode: "closest",
            xaxis: {
                gridcolor: "rgba(255,0,0,0.5)",
                autotick: false,
                tick0: 0,
                dtick: 10,
                showgrid: true,
                range: [0, 360],
                title: {
                    text: "Orbital Plane"
                }
            },
            yaxis: {
                gridcolor: "rgba(255,0,0,0.3)",
                tick0: 0,
                dtick: 2222,
                showgrid: true,
                range: [0, 4e4],
                title: {
                    text: "Satellite spacing kms (great circle)"
                }
            },
            titlefont: {
                size: 13
            },
            title: "Constellation Structure, " + cnt + " sats (β code)",
            paper_bgcolor: "#202020",
            plot_bgcolor: "#202020",
            font: {
                color: "white"
            },
            margin: {
                l: 80,
                t: 50,
                b: 50,
                r: 10,
                pad: 0
            },
            scene: {
                xaxis: {
                    title: {
                        text: "Orbital Plane"
                    },
                    backgroundcolor: "rgb(200, 200, 230)",
                    gridcolor: "rgb(255, 255, 255)",
                    showbackground: true,
                    zerolinecolor: "rgb(255, 255, 255)"
                },
                yaxis: {
                    title: {
                        text: "Mean Anomoly"
                    },
                    backgroundcolor: "rgb(230, 200,230)",
                    gridcolor: "rgb(255, 255, 255)",
                    showbackground: true,
                    zerolinecolor: "rgb(255, 255, 255)"
                },
                zaxis: {
                    title: {
                        text: ""
                    },
                    backgroundcolor: "rgb(230, 230,200)",
                    gridcolor: "rgb(255, 255, 255)",
                    showbackground: true,
                    zerolinecolor: "rgb(255, 255, 255)"
                }
            }
        };
        Plotly.newPlot("myDiv1", data, layout, {
            responsive: true,
            modeBarButtonsToRemove: ["zoom2d", "pan2d", "select2d", "lasso2d", "zoomIn2d", "zoomOut2d", "resetScale2d", "toggleSpikelines", "toImage", "toggleHover", "hoverClosestCartesian", "hoverCompareCartesian"],
            displaylogo: false
        });
        document.getElementById("myDiv1").style.display = "";
        var myPlot = document.getElementById("myDiv1");
        myPlot.on("plotly_click", function(data) {
            var pts = null;
            for (var i = 0; i < data.points.length; i++) {
                pts = data.points[i].text
            }
            if (pts) {
                var norad = pts.split(" ")[0];
                for (var x = 0; x < showingsats.length; x++)
                    if (showingsats[x].id == norad) {
                        selected[x] = true;
                        ppp.plugins.pings.sel(x, ppp, true)
                    }
            }
        })
    })
}
var boot2 = setInterval(function() {
    if (typeof planetaryjs == "object") {
        clearTimeout(boot2);
        ppp = function() {
            var planet = planetaryjs.planet();
            var canvas = document.getElementById("quakeCanvas");
            planet.loaded = new Object;
            if (navigator.userAgent.indexOf("GoNativeIOS") !== -1 || settings && settings.scopemode) {
                planet.loadPlugin(autocenter({
                    extraHeight: 0
                }));
                planet.loadPlugin(autoscale({
                    extraHeight: 0
                }));
                canvas.style.top = "0px";
                console.log("scope mode")
            } else if (typeof window.StackView == "object") {
                planet.loadPlugin(autocenter({
                    extraHeight: 0
                }));
                planet.loadPlugin(autoscale({
                    extraHeight: 0
                }));
                canvas.style.top = "0px";
                console.log("app mode")
            } else {
                planet.loadPlugin(autocenter({
                    extraHeight: -50
                }));
                planet.loadPlugin(autoscale({
                    extraHeight: -50
                }))
            }
            if (settings && settings.rotating) {
                planet.loadPlugin(autorotate(15 / 3600))
            }
            if (settings && settings.theme == "lite") {
                planet.loadPlugin(planetaryjs.plugins.earth({
                    topojson: {
                        file: "world-110m.json"
                    },
                    oceans: {
                        fill: "#a4bac7"
                    },
                    land: {
                        fill: "#d7c7ad",
                        stroke: "#766951"
                    },
                    borders: {
                        stroke: "#a5967e"
                    }
                }))
            } else {
                planet.loadPlugin(planetaryjs.plugins.earth({
                    topojson: {
                        file: "world-110m.json"
                    },
                    oceans: {
                        fill: "#001320"
                    },
                    land: {
                        fill: "#06304e"
                    },
                    borders: {
                        stroke: "#001320"
                    }
                }))
            }
            if (!(settings && settings.scopemode)) {
                if (hexesfile)
                    planet.loadPlugin(planetaryjs.plugins.coverage());
                if (hexesfile1)
                    planet.loadPlugin(planetaryjs.plugins.intensity());
                if (hexesfile2)
                    planet.loadPlugin(planetaryjs.plugins.peeps());
                planet.loadPlugin(planetaryjs.plugins.basestations());
                try {
                    planet.loadPlugin(planetaryjs.plugins.tips())
                } catch (err) {
                    console.log("no tips loaded")
                }
            }
            planet.loadPlugin(planetaryjs.plugins.pings());
            planet.loadPlugin(planetaryjs.plugins.myloc());
            planet.loadPlugin(planetaryjs.plugins.zoom({
                scaleExtent: [50, 15e3]
            }));
            planet.loadPlugin(planetaryjs.plugins.drag({
                onDragStart: function() {
                    this.plugins.automomentum.pause()
                },
                onDragEnd: function() {
                    this.plugins.automomentum.resume()
                }
            }));
            planet.loadPlugin(automomentum());
            planet.setProjection("othographic");
            planet.draw(canvas);
            if (settings && settings.myloc && settings.myloc.length == 2 && settings.myloc[0] && settings.myloc[1]) {
                planet.plugins.myloc.set([settings.myloc[0], settings.myloc[1]]);
                {
                    setTimeout(function() {
                        if (planet.projection_selected == "orthographic") {
                            var lng = settings.myloc[1];
                            var lat = settings.myloc[0];
                            var rotation = planet.projection.rotate();
                            rotation[0] = -lng;
                            if (planet.projection_selected == "orthographic") {
                                rotation[1] = -lat
                            }
                            rotation[2] = 0;
                            planet.projection.scale(1600);
                            planet.projection.rotate(rotation)
                        }
                        planet.interacted = new Date
                    }, 1e3)
                }
            } else {
                var isLL = urlParams && urlParams.get("lat") !== null && urlParams.get("long") !== null && urlParams.get("zoom") !== null;
                if (isLL) {
                    setTimeout(function() {
                        const lng = parseFloat(urlParams.get("long"));
                        const lat = parseFloat(urlParams.get("lat"));
                        const z = parseInt(urlParams.get("zoom"));
                        console.log(lng, lat, z);
                        var rotation = planet.projection.rotate();
                        rotation[0] = -lng;
                        rotation[1] = -lat;
                        rotation[2] = 0;
                        planet.projection.scale(z);
                        planet.projection.rotate(rotation)
                    }, 1e3)
                } else {
                    planet.projection.rotate([100, -10, 0])
                }
            }
            if (groundfile)
                d3.json(groundfile + "?" + Math.random(), function(err, data) {
                    if (err)
                        return;
                    planet.plugins.basestations.set(data);
                    grounddata = data
                });
            if (hexesfile)
                d3.json(hexesfile + "?" + Math.random(), function(err, data) {
                    if (!err)
                        planet.plugins.coverage.set(data)
                });
            {
                var j = 0;
                last_fetched = (new Date).getTime() - 12e4;
                var currentTime = 0;
                var lastTick = (new Date).getTime();
                var div = d3.select("body").append("div").attr("class", "tooltip").style("opacity", 0);
                var julian = julofyear(new Date);
                d3.select("#quakeCanvas").on("click", function() {
                    if (d3.event.defaultPrevented)
                        return;
                    planet.plugins.automomentum.cancel();
                    var x = d3.mouse(this)[0];
                    var y = d3.mouse(this)[1];
                    var p = planet.projection.invert([x, y]);
                    var m = 999999;
                    var mc = null;
                    if (grounddata)
                        for (var i = 0; i < grounddata.basestations.length; i++) {
                            var o = grounddata.basestations[i];
                            var xdiff = o.lat - p[1];
                            var ydiff = o.lng - p[0];
                            var d = xdiff * xdiff + ydiff * ydiff;
                            if (d < m && d < .5) {
                                m = d;
                                mc = i
                            }
                        }
                    if (mc != null) {
                        let isIOS = /iPad|iPhone|iPod/.test(navigator.platform) || navigator.platform === "MacIntel";
                        var html;
                        var d = grounddata.basestations[mc];
                        if (typeof window.StackView == "object") {
                            html = "Lat: " + d.lat + " Long: " + d.lng + "<br>"
                        } else {
                            if (isIOS) {
                                html = "maps://?t=k&z=19&ll=" + d.lat + "," + d.lng + "&q=" + d.lat + "," + d.lng
                            } else {
                                html = "https://www.google.com/maps/@?api=1&map_action=map&basemap=satellite&zoom=19&center=" + d.lat + "," + d.lng
                            }
                            html = "<a target=_new href='" + html + "'>map link</a> (new window)<br>"
                        }
                        var url = "/app/groundstations/starlink/" + d.town + " " + d.cc;
                        url = encodeURIComponent(url.replace(/ /g, "-"));
                        const moredata = "<a href='" + url + "'>" + d.town + " " + d.cc + "</a>";
                        modal_content("Ground station", moredata + "<br>" + html + "<hr>" + d.desc);
                        planet.interacted = new Date;
                        return
                    }
                    var i = planet.plugins.pings.find((new Date).getTime(), p[0], p[1], [x, y]);
                    select_unselect(planet, i);
                    planet.interacted = new Date
                });
                var paused = false;
                setInterval(function() {
                    if (paused || ppp && ppp.stopped)
                        return;
                    var now = (new Date).getTime();
                    var stale = now - last_fetched;
                    var spinner_on = false;
                    var savesel = [];
                    if (stale > 125e3 && !is_fetching) {
                        savesel = planet.plugins.pings.getsel(planet);
                        planet.plugins.pings.wipe();
                        document.getElementById("loading_spinner").style.display = "block";
                        spinner_on = true
                    }
                    if (hexesfile1 && settings && settings.showintensity && !planet.loaded[hexesfile1]) {
                        planet.loaded[hexesfile1] = true;
                        d3.json(hexesfile1 + "?" + Math.random(), function(err, data) {
                            if (!err)
                                planet.plugins.intensity.set(data)
                        })
                    }
                    if (hexesfile2 && settings && settings.showpeeps != "no" && !planet.loaded[hexesfile2]) {
                        planet.loaded[hexesfile2] = true;
                        d3.json(hexesfile2 + "?" + Math.random(), function(err, data) {
                            if (!err)
                                planet.plugins.peeps.set(data)
                        })
                    }
                    if (stale > 12e4 && !is_fetching) {
                        is_fetching = true;
                        d3.json(satfile + "?" + Math.random() + "+" + sig, function(err, data) {
                            if (data) {
                                if (spinner_on)
                                    document.getElementById("loading_spinner").style.display = "none";
                                showingsats = new Array;
                                last_fetched = now;
                                var julian = julofyear(new Date);
                                selected = new Object;
                                planet.plugins.pings.wipe();
                                planet.plugins.pings.offsets(offset, data.stamp);
                                var toPing = data.sats;
                                var cntign = 0;
                                var cntinc = 0;
                                var n2l = new Array;
                                if (data.launches) {
                                    planet.plugins.pings.addlaunches(data.launches);
                                    for (var j = 0; j < data.launches.length; j++) {
                                        n2l[parseInt(data.launches[j].id)] = data.launches[j]
                                    }
                                }
                                for (var i = 0; i < toPing.length; i++) {
                                    var ping = toPing[i];
                                    ping.l = n2l[parseInt(ping.name)];
                                    var ign = (!isQp || savesel.length) && ignoresat(ping);
                                    ping.mag = 5;
                                    if (!ign) {
                                        showingsats.push(ping);
                                        planet.plugins.pings.add(ping.lng, ping.lat, {
                                            id: ping.id,
                                            name: ping.name,
                                            oname: ping.oname,
                                            lat2: ping.lat2,
                                            illum: ping.illum,
                                            long2: ping.lng2,
                                            alt: ping.alt,
                                            alt2: ping.alt2,
                                            angle: null,
                                            color: null,
                                            selected: false,
                                            raan: ping.raan
                                        });
                                        cntinc++
                                    } else {
                                        cntign++
                                    }
                                }
                                for (var y = 0; y < savesel.length; y++) {
                                    var id = savesel[y];
                                    for (var x = 0; x < showingsats.length; x++)
                                        if (showingsats[x].id == id) {
                                            selected[x] = true;
                                            planet.plugins.pings.sel(x, planet, true)
                                        }
                                }
                                if (!planet.qp_done++)
                                    zoom_to_qp(planet);
                                if (0) {
                                    d3.select("#magnitudes").selectAll("li").data(showingsats.slice(0, maxsize)).enter().append("li").text(function(d) {
                                        return d.name
                                    }).attr("class", function(d) {
                                        if (d.alt == 0) {
                                            return "deadsat"
                                        }
                                        return d.alt < 510 || d.epoch < julian - 7 ? "oldsat" : "goodsat"
                                    }).on("click", function(d, i) {
                                        if (selected[i] !== undefined) {
                                            planet.plugins.pings.unsel(i, planet);
                                            unsel_norad(i);
                                            delete selected[i]
                                        } else {
                                            graphAlt(d.id);
                                            planet.plugins.pings.sel(i, planet);
                                            selected[i] = true
                                        }
                                    }).on("mouseover", function(d, i) {
                                        div.transition().duration(200).style("opacity", .98);
                                        if (d.alt == 0) {
                                            div.html("name: " + d.name + "<br/>" + "norad: " + d.id + "<br/>" + "de-orbit").style("left", d3.event.pageX + 20 + "px").style("top", d3.event.pageY - 28 + "px")
                                        } else {
                                            div.html("name: " + d.name + "<br/>" + "norad: " + d.id + "<br/>" + "alt: " + d.alt + "km<br/>" + "plane: " + Math.floor(d.raan * 10) / 10 + "°<br/>" + (classify.length && classify[d.id] ? "state: " + classify[d.id].orbit + "<br/>" + "actvity: " + classify[d.id].doing + "<br/>" : "") + "fix: " + Math.floor((julian - d.epoch) * 10) / 10 + "d old<br/>").style("left", d3.event.pageX + 20 + "px").style("top", d3.event.pageY - 28 + "px")
                                        }
                                    }).on("mouseout", function(d) {
                                        div.transition().duration(500).style("opacity", 0)
                                    })
                                }
                                tryct = 0
                            } else {
                                console.error(err);
                                document.getElementById("loading_spinner").style.display = "none";
                                if (tryct++ > 1)
                                    myalert("No internet connection?");
                                var t = (new Date).getTime();
                                last_fetched = t - 11e4
                            }
                            is_fetching = false
                        })
                    }
                    if (currentTime++ >= 3600 * 24) {
                        currentTime = 1;
                        ppp.stopped = paused = true;
                        myalert("Still watching?");
                        ppp.stopped = paused = false
                    }
                }, 1e3)
            }
            function autocenter(options) {
                options = options || {};
                var needsCentering = false;
                var globe = null;
                var resize = function() {
                    var width = window.innerWidth + (options.extraWidth || 0);
                    var height = window.innerHeight + (options.extraHeight || 0);
                    if (globe.canvas.width != width || globe.canvas.height != height) {
                        globe.canvas.width = width;
                        globe.canvas.height = height;
                        if (planet.projection_selected == "orthographic")
                            globe.projection.translate([width / 2, height / 2])
                    }
                };
                return function(planet) {
                    globe = planet;
                    planet.onInit(function() {
                        needsCentering = true;
                        d3.select(window).on("resize", function() {
                            needsCentering = true
                        })
                    });
                    planet.onDraw(function() {
                        if (needsCentering) {
                            needsCentering = false;
                            resize()
                        }
                    })
                }
            }
            function autoscale(options) {
                options = options || {};
                return function(planet) {
                    planet.onInit(function() {
                        var width = window.innerWidth + (options.extraWidth || 0);
                        var height = window.innerHeight + (options.extraHeight || 0);
                        if (width && height)
                            planet.projection.scale(Math.min(width, height) / 2.2);
                        else {
                            planet.projection.scale(200)
                        }
                    })
                }
            }
            function automomentum() {
                return function(planet) {
                    var lastTick = null;
                    var paused = true;
                    planet.plugins.automomentum = {
                        pause: function() {
                            paused = true
                        },
                        resume: function() {
                            paused = false
                        },
                        cancel: function() {
                            planet.momentum_x = planet.momentum_y = 0
                        }
                    };
                    planet.onDraw(function() {
                        if (paused || !lastTick) {
                            lastTick = new Date
                        } else {
                            planet.momentum_x *= .9;
                            planet.momentum_y *= .9;
                            if (planet.momentum_x > .1 || planet.momentum_y > .1 || planet.momentum_x < -.1 || planet.momentum_y < -.1) {
                                if (planet.projection_selected == "orthographic") {
                                    var rotation = planet.projection.rotate();
                                    rotation[0] += planet.momentum_x;
                                    rotation[1] -= planet.momentum_y;
                                    if (rotation[1] > 90)
                                        rotation[1] = 90;
                                    if (rotation[1] < -90)
                                        rotation[1] = -90;
                                    if (rotation[0] >= 180)
                                        rotation[0] -= 360;
                                    planet.projection.rotate(rotation)
                                } else {
                                    var o = planet.projection.translate();
                                    planet.projection.translate([o[0] + planet.momentum_x, o[1] + planet.momentum_y])
                                }
                            }
                        }
                    })
                }
            }
            function autorotate(degPerSec) {
                return function(planet) {
                    var lastTick = null;
                    var paused = false;
                    planet.plugins.autorotate = {
                        pause: function() {
                            paused = true
                        },
                        resume: function() {
                            paused = false
                        }
                    };
                    planet.onDraw(function() {
                        if (paused || !lastTick) {
                            lastTick = new Date
                        } else {
                            var now = new Date;
                            var delta = now - lastTick;
                            var rotation = planet.projection.rotate();
                            rotation[0] += degPerSec * delta / 1e3;
                            if (rotation[0] >= 180)
                                rotation[0] -= 360;
                            planet.projection.rotate(rotation);
                            lastTick = now
                        }
                    })
                }
            }
            return planet
        }()
    }
}, 50);
