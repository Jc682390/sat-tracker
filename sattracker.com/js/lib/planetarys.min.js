var Geodesic, DMS, geod;
var framemod = 4;
var frame_ms = 20;
var frame_hi = false;
function toRadians(degrees) {
    return degrees * Math.PI / 180
}
function toDegrees(radians) {
    return radians * 180 / Math.PI
}
function bearing(startLat, startLng, destLat, destLng) {
    startLat = toRadians(startLat);
    startLng = toRadians(startLng);
    destLat = toRadians(destLat);
    destLng = toRadians(destLng);
    y = Math.sin(destLng - startLng) * Math.cos(destLat);
    x = Math.cos(startLat) * Math.sin(destLat) - Math.sin(startLat) * Math.cos(destLat) * Math.cos(destLng - startLng);
    brng = Math.atan2(y, x);
    brng = toDegrees(brng);
    return (brng + 360) % 360
}
function azelev(f, t, alt) {
    var a = llhxyz(f[1], f[0], 0);
    var b = llhxyz(t[1], t[0], alt);
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var dx = b[0] - a[0];
    var dy = b[1] - a[1];
    var dz = b[2] - a[2];
    var slant = Math.sqrt(dx * dx + dy * dy + dz * dz);
    var ev = (x * dx + y * dy + z * dz) / Math.sqrt((x * x + y * y + z * z) * (dx * dx + dy * dy + dz * dz));
    ev = Math.acos(ev);
    var az = (-z * x * dx - z * y * dy + (x * x + y * y) * dz) / Math.sqrt((x * x + y * y) * (x * x + y * y + z * z) * (dx * dx + dy * dy + dz * dz));
    var az2 = (-y * dx + x * dy) / Math.sqrt((x * x + y * y) * (dx * dx + dy * dy + dz * dz));
    az = (Math.atan2(az2, az) + Math.PI * 2) % (Math.PI * 2);
    return [90 - ev * 180 / Math.PI, az * 180 / Math.PI, slant]
}
function azelev_old(f, t, alt) {
    var rx_lon = f[0]
      , rx_lat = f[1];
    var sat_lon = t[0]
      , sat_lat = t[1];
    var delta_lon = rx_lon - sat_lon;
    var delta_lat = rx_lat - sat_lat;
    const R0 = 6370;
    var rx_az = Math.atan(Math.tan(Math.PI / 180 * delta_lon) / Math.sin(Math.PI / 180 * delta_lat)) * (180 / Math.PI);
    if (delta_lat > 0) {
        rx_az += 180
    } else {
        if (rx_az < 0) {
            rx_az += 360
        }
    }
    var num = Math.cos(delta_lat * (Math.PI / 180)) * Math.cos(delta_lon * (Math.PI / 180)) - R0 / (R0 + alt);
    var den = Math.sqrt(1 - Math.pow(Math.cos(delta_lat * (Math.PI / 180)) * Math.cos(delta_lon * (Math.PI / 180)), 2));
    var rx_el = 180 / Math.PI * Math.atan(num / den);
    var test2 = azelev2(f, t, alt);
    return [rx_el, rx_az]
}
function inclusion(visdata, name, norad, dist, f, t, alt) {
    var rx_lon, rx_lat, sat_lon, sat_lat, rx_az, rx_el;
    var delta_lon, delta_lat, num, den;
    var R0 = 6370;
    var h = alt;
    var v = azelev([f[0], f[1]], [t[0], t[1]], alt);
    rx_az = v[1];
    rx_el = v[0];
    var vis = false;
    var face = "north";
    if (rx_lat < 0) {
        face = "south"
    }
    if (ppp.settings && ppp.settings.dishyface && ppp.settings.dishyface != "")
        face = ppp.settings.dishyface;
    if (ppp.settings && ppp.settings.group == "GPS") {
        vis = rx_el >= 25
    } else {
        if (face == "north") {
            if (rx_el >= 25 && (rx_az >= 360 - 60 || rx_az <= 60)) {
                vis = true
            } else if (rx_el >= 75 && (rx_az >= 180 - 60 && rx_az <= 180 + 60)) {
                vis = true
            }
        } else if (face == "south") {
            if (rx_el >= 25 && (rx_az >= 180 - 60 && rx_az <= 180 + 60)) {
                vis = true
            } else if (rx_el >= 75 && (rx_az >= 360 - 60 || rx_az <= 60)) {
                vis = true
            }
        } else if (face == "up") {
            if (rx_el >= 40) {
                vis = true
            }
        } else {
            vis = false
        }
    }
    if (rx_el >= 25 && alt >= 500) {
        visdata.push({
            t: new Date,
            name: name,
            norad: norad,
            dist: dist,
            elev: rx_el.toFixed(1),
            az: rx_az.toFixed(1),
            vis: vis
        });
        while (visdata.length > 1e4)
            visdata.shift()
    }
    return [rx_el, rx_az, v[2], vis]
}
function isSunlit(date, lonDeg, latDeg, heightMeters) {
    const sunTimes = SunCalc.getTimes(date, latDeg, lonDeg, heightMeters);
    let sunlightEnd = new Date((sunTimes.sunsetStart.getTime() + sunTimes.goldenHour.getTime()) / 2);
    if (date > sunTimes.dawn && date < sunlightEnd) {
        return true
    } else
        return false
}
(function(root, factory) {
    if (typeof define === "function" && define.amd) {
        define(["d3", "topojson"], function(d3, topojson) {
            return root.planetaryjs = factory(d3, topojson, root)
        })
    } else if (typeof exports === "object") {
        module.exports = factory(require("d3"), require("topojson"))
    } else {
        root.planetaryjs = factory(root.d3, root.topojson, root)
    }
}
)(this, function(d3, topojson, window) {
    "use strict";
    var originalPlanetaryjs = null;
    if (window)
        originalPlanetaryjs = window.planetaryjs;
    var plugins = [];
    var doDrawLoop = function(planet, canvas, hooks) {
        function workLoop() {
            planet.frame++;
            if (planet.stopped) {
                return
            }
            var delta = new Date - planet.interacted;
            if (planet.settings && planet.settings.scopemode) {
                if (planet.frame % (5 * framemod) != 0)
                    return
            } else {
                if (delta > 1e3 && planet.frame % 50 != 0)
                    return
            }
            frame_hi = delta > 1e3 ? false : true;
            if (planet.frame % framemod == 0) {
                var t0 = performance.now();
                planet.context.clearRect(0, 0, canvas.width, canvas.height);
                for (var i = 0; i < hooks.onDraw.length; i++) {
                    hooks.onDraw[i]()
                }
                var ms = performance.now() - t0;
                frame_ms = frame_ms * .8 + .2 * ms;
                if (frame_ms < 20 || frame_hi) {
                    framemod = 1
                } else if (frame_ms < 40) {
                    framemod = 2
                } else {
                    framemod = 4
                }
                if (planet.settings && planet.settings.scopemode && typeof window.ScopeView == "object")
                    ScopeView.postMessage(JSON.stringify(planet.scope))
            }
        }
        planet.frame = 0;
        if (!planet.interacted)
            planet.interacted = new Date;
        setInterval(function() {
            workLoop()
        }, 20)
    };
    var initPlugins = function(planet, localPlugins) {
        for (var i = plugins.length - 1; i >= 0; i--) {
            localPlugins.unshift(plugins[i])
        }
        if (localPlugins.length === 0) {
            if (planetaryjs.plugins.earth)
                planet.loadPlugin(planetaryjs.plugins.earth());
            if (planetaryjs.plugins.pings)
                planet.loadPlugin(planetaryjs.plugins.pings())
        }
        for (i = 0; i < localPlugins.length; i++) {
            localPlugins[i](planet)
        }
    };
    var runOnInitHooks = function(planet, canvas, hooks) {
        if (hooks.onInit.length) {
            var completed = 0;
            var doNext = function(callback) {
                var next = hooks.onInit[completed];
                if (next.length) {
                    next(function() {
                        completed++;
                        callback()
                    })
                } else {
                    next();
                    completed++;
                    setTimeout(callback, 0)
                }
            };
            var check = function() {
                if (completed >= hooks.onInit.length)
                    doDrawLoop(planet, canvas, hooks);
                else
                    doNext(check)
            };
            doNext(check)
        } else {
            doDrawLoop(planet, canvas, hooks)
        }
    };
    var startDraw = function(planet, canvas, localPlugins, hooks) {
        planet.canvas = canvas;
        planet.context = canvas.getContext("2d");
        if (planet.stopped !== true) {
            initPlugins(planet, localPlugins)
        }
        planet.stopped = false;
        runOnInitHooks(planet, canvas, hooks)
    };
    var planetaryjs = {
        plugins: {},
        noConflict: function() {
            window.planetaryjs = originalPlanetaryjs;
            return planetaryjs
        },
        loadPlugin: function(plugin) {
            plugins.push(plugin)
        },
        planet: function() {
            var localPlugins = [];
            var hooks = {
                onInit: [],
                onDraw: [],
                onStop: []
            };
            if (settings.theme == "lite") {
                document.body.style.background = "none";
                document.body.style.color = "black";
                document.body.style.backgroundColor = "grey"
            }
            var planet = {
                style: {
                    dark: {
                        hi: "rgb(255,255,255)",
                        dim: "rgba(255,255,255,0.4)",
                        red: "rgb(255,0,0)",
                        yel: "rgb(255,255,0)",
                        green: "rgb(0,255,0)"
                    },
                    lite: {
                        hi: "rgb(0,0,0)",
                        dim: "rgba(0,0,0,0.4)",
                        red: "rgb(128,0,0)",
                        yel: "rgb(1278,128,0)",
                        green: "rgb(0,128,0)"
                    }
                },
                projection_selected: "orthographic",
                plugins: {},
                draw: function(canvas) {
                    startDraw(planet, canvas, localPlugins, hooks)
                },
                debug: function() {
                    return {
                        hooks: hooks,
                        localPlugins: localPlugins
                    }
                },
                onInit: function(fn) {
                    hooks.onInit.push(fn)
                },
                onDraw: function(fn) {
                    hooks.onDraw.push(fn)
                },
                onStop: function(fn) {
                    hooks.onStop.push(fn)
                },
                setSettings: function(s) {
                    planet.settings = s
                },
                setProjection: function(p) {
                    if (planet.projection_selected == p) {
                        return
                    }
                    planet.projection_selected = p;
                    if (planet.projection_selected == "mercator") {
                        planet.projection = d3.geo.mercator()
                    } else if (planet.projection_selected == "albersusa") {
                        planet.projection = d3.geo.equirectangular().scale(1300).translate([487.5, 305])
                    } else if (planet.projection_selected == "azimuthal") {
                        planet.projection = d3.geo.azimuthalEqualArea()
                    } else {
                        planet.projection = d3.geo.orthographic().clipAngle(90)
                    }
                    planet.path = d3.geo.path().projection(planet.projection);
                    if (planet.canvas)
                        planet.canvas.width = planet.canvas.width - 1;
                    window.dispatchEvent(new Event("resize"));
                    var width = window.innerWidth;
                    var height = window.innerHeight;
                    if (width && height) {
                        planet.projection.scale(Math.min(width, height) / 2.2)
                    } else {
                        planet.projection.scale(200)
                    }
                },
                loadPlugin: function(plugin) {
                    localPlugins.push(plugin)
                },
                stop: function() {
                    planet.stopped = true;
                    for (var i = 0; i < hooks.onStop.length; i++) {
                        hooks.onStop[i](planet)
                    }
                },
                withSavedContext: function(fn) {
                    if (!this.context) {
                        throw new Error("No canvas to fetch context for")
                    }
                    this.context.save();
                    fn(this.context);
                    this.context.restore()
                }
            };
            if (planet.projection_selected == "mercator") {
                planet.projection = d3.geo.mercator()
            } else {
                planet.projection = d3.geo.orthographic().clipAngle(90)
            }
            planet.path = d3.geo.path().projection(planet.projection);
            return planet
        }
    };
    planetaryjs.plugins.topojson = function(config) {
        return function(planet) {
            planet.plugins.topojson = {};
            planet.onInit(function(done) {
                if (config.world) {
                    planet.plugins.topojson.world = config.world;
                    setTimeout(done, 0)
                } else {
                    var file = "4.json";
                    d3.json(file, function(err, world) {
                        if (err) {
                            throw new Error("Could not load JSON " + file)
                        }
                        planet.plugins.topojson.world = world;
                        done()
                    })
                }
            })
        }
    }
    ;
    planetaryjs.plugins.oceans = function(config) {
        return function(planet) {
            planet.onDraw(function() {
                planet.withSavedContext(function(context) {
                    context.beginPath();
                    planet.path.context(context)({
                        type: "Sphere"
                    });
                    context.fillStyle = config.fill || "black";
                    context.fill()
                })
            })
        }
    }
    ;
    planetaryjs.plugins.land = function(config) {
        return function(planet) {
            var land = null;
            var states = null;
            var prov = null;
            planet.onInit(function() {
                var world = planet.plugins.topojson.world;
                land = topojson.feature(world, world.objects.land);
                states = topojson.feature(world, world.objects.states);
                prov = topojson.feature(world, world.objects.provinces)
            });
            planet.onDraw(function() {
                planet.withSavedContext(function(context) {
                    context.beginPath();
                    planet.path.context(context)(land);
                    if (config.fill !== false) {
                        context.fillStyle = config.fill || "white";
                        context.fill()
                    }
                    if (config.stroke) {
                        if (config.lineWidth)
                            context.lineWidth = config.lineWidth;
                        context.strokeStyle = config.stroke;
                        context.stroke()
                    }
                    if (planet.projection.scale() > 1e3) {
                        context.beginPath();
                        planet.path.context(context)(states);
                        context.strokeStyle = settings.theme == "lite" ? "#888" : "black";
                        context.stroke();
                        context.beginPath();
                        planet.path.context(context)(prov);
                        context.strokeStyle = settings.theme == "lite" ? "#888" : "black";
                        context.stroke()
                    }
                    if (planet.projection.scale() < 1300) {
                        if (!frame_hi || frame_ms < 20) {
                            var graticule = d3.geo.graticule();
                            context.beginPath();
                            context.strokeStyle = settings.theme == "lite" ? "#ccc" : "#333";
                            var geoGenerator = d3.geo.path().projection(planet.projection).context(context);
                            geoGenerator(graticule());
                            context.stroke()
                        }
                    }
                })
            })
        }
    }
    ;
    planetaryjs.plugins.borders = function(config) {
        return function(planet) {
            var borders = null;
            var borderFns = {
                internal: function(a, b) {
                    return a.id !== b.id
                },
                external: function(a, b) {
                    return a.id === b.id
                },
                both: function(a, b) {
                    return true
                }
            };
            planet.onInit(function() {
                var world = planet.plugins.topojson.world;
                var countries = world.objects.countries;
                var type = config.type || "internal";
                borders = topojson.mesh(world, countries, borderFns[type])
            });
            planet.onDraw(function() {
                const scale = planet.projection.scale();
                if (scale > 150) {
                    if (!frame_hi || frame_ms < 20) {
                        planet.withSavedContext(function(context) {
                            context.beginPath();
                            planet.path.context(context)(borders);
                            context.strokeStyle = config.stroke || "gray";
                            if (config.lineWidth)
                                context.lineWidth = config.lineWidth;
                            context.stroke()
                        })
                    }
                }
            })
        }
    }
    ;
    planetaryjs.plugins.earth = function(config) {
        config = config || {};
        var topojsonOptions = config.topojson || {};
        var oceanOptions = config.oceans || {};
        var landOptions = config.land || {};
        var bordersOptions = config.borders || {};
        return function(planet) {
            if (!settings.scopemode) {
                planetaryjs.plugins.topojson(topojsonOptions)(planet);
                planetaryjs.plugins.oceans(oceanOptions)(planet);
                planetaryjs.plugins.land(landOptions)(planet);
                planetaryjs.plugins.borders(bordersOptions)(planet)
            }
        }
    }
    ;
    planetaryjs.isearch = function(str) {
        var pings = planetaryjs.plugins.pings
    }
    ;
    planetaryjs.plugins.tips = function(config) {
        var data = window.tips;
        var setTips = function(x) {
            data = x
        };
        var drawTips = function(planet, context, now) {};
        var isearch = function(str) {
            var m = new Array;
            const r = new RegExp(str,"i");
            if (data)
                for (var x = 0; x < data.length; x++) {
                    if ((data[x].NORAD_CAT_ID + " re-entry").match(r)) {
                        m.push({
                            typ: "re-entry",
                            id: data[x].NORAD_CAT_ID,
                            ll: [data[x].LAT, data[x].LON],
                            m: data[x].NORAD_CAT_ID + " re-entry"
                        })
                    }
                }
            return m
        };
        return function(planet) {
            planet.plugins.tips = {
                set: setTips,
                draw: drawTips,
                isearch: isearch
            };
            planet.onDraw(function() {
                var context = planet.context;
                if (window.tips) {
                    data = window.tips
                }
                context.fillStyle = "rgb(255,255,0)";
                const scale = planet.projection.scale();
                const character = "";
                if (data) {
                    for (var x = 0; x < data.length; x++) {
                        var loc = [data[x].LON, data[x].LAT];
                        var visible = true;
                        if (planet.projection_selected == "orthographic") {
                            var geoangle = d3.geo.distance(loc, [-planet.projection.rotate()[0], -planet.projection.rotate()[1]]);
                            visible = geoangle > 1.5707963267949 ? false : true
                        }
                        if (visible) {
                            var cxy = planet.projection(loc);
                            var sz = 5;
                            var t0 = Math.floor(performance.now() / 1e3);
                            const scale = planet.projection.scale();
                            context.fillStyle = t0 % 2 == 0 ? "rgb(255,255,0)" : "rgb(255,0,0)";
                            context.strokeStyle = t0 % 2 == 0 ? "rgb(255,255,0)" : "rgb(255,0,0)";
                            if (scale < 1e3)
                                context.fillRect(Math.floor(cxy[0]), Math.floor(cxy[1]), sz, sz);
                            else {
                                var a, b;
                                var lab = "heading south";
                                var r;
                                if (data[x].DIRECTION == "descending") {
                                    a = 90;
                                    b = 10;
                                    lab = "heading south ";
                                    r = Math.PI / 4
                                } else {
                                    a = 10;
                                    b = 90;
                                    lab = "heading north ";
                                    r = Math.PI / 4
                                }
                                if (data[x].incl > 80) {
                                    a = 90;
                                    b = 10;
                                    if (data[x].DIRECTION == "descending")
                                        r = Math.PI / 2 + (data[x].incl - 90) * Math.PI / 180;
                                    else
                                        r = Math.PI / 2 - (data[x].incl - 90) * Math.PI / 180
                                }
                                context.beginPath();
                                context.ellipse(Math.floor(cxy[0]), Math.floor(cxy[1]), a, b, r, 0, 2 * Math.PI);
                                context.stroke()
                            }
                            if (scale > 1e3) {
                                context.fillStyle = planet.style[settings.theme].hi;
                                context.font = "12px Arial";
                                context.fillText(data[x].NORAD_CAT_ID + " re-entry", cxy[0] - 30, cxy[1] + 20);
                                if (scale > 1500) {
                                    context.fillText(data[x].DECAY_EPOCH + " UTC", cxy[0] - 30, cxy[1] + 20 + 15);
                                    context.fillText("+/- " + data[x].WINDOW + " minutes", cxy[0] - 30, cxy[1] + 20 + 15 + 15);
                                    context.fillText("Forecasted: " + data[x].fdelta + " Splash: " + data[x].delta, cxy[0] - 30, cxy[1] + 20 + 15 + 15 + 15);
                                    context.fillText(lab, cxy[0] - 30, cxy[1] + 20 + 15 + 15 + 15 + 15)
                                }
                            }
                        }
                    }
                }
            })
        }
    }
    ;
    planetaryjs.plugins.basestations = function(config) {
        var data = 0;
        var setBasestations = function(x) {
            data = x
        };
        var drawBasestations = function(planet, context, now) {};
        var isearch = function(str) {
            var m = new Array;
            const r = new RegExp(str,"i");
            if (data)
                for (var x = 0; x < data.basestations.length; x++) {
                    if ((data.basestations[x].town + "").match(r)) {
                        m.push({
                            typ: "ground station",
                            id: data.basestations[x].town,
                            ll: [data.basestations[x].lat, data.basestations[x].lng],
                            m: data.basestations[x].town
                        })
                    }
                }
            return m
        };
        return function(planet) {
            planet.plugins.basestations = {
                set: setBasestations,
                draw: drawBasestations,
                isearch: isearch
            };
            planet.onDraw(function() {
                var context = planet.context;
                context.fillStyle = "rgb(255,255,0)";
                const scale = planet.projection.scale();
                const character = "";
                if (data && (!planet.settings || planet.settings.showgnd == true)) {
                    var fs = Math.floor(scale / 200 * 4);
                    if (fs < 4)
                        fs = 4;
                    if (fs > 20)
                        fs = 20;
                    for (var x = 0; x < data.basestations.length; x++) {
                        var loc = [data.basestations[x].lng, data.basestations[x].lat];
                        var visible = true;
                        if (planet.projection_selected == "orthographic") {
                            var geoangle = d3.geo.distance(loc, [-planet.projection.rotate()[0], -planet.projection.rotate()[1]]);
                            visible = geoangle > 1.5707963267949 ? false : true
                        }
                        if (visible) {
                            var cxy = planet.projection(loc);
                            if (scale > 1400) {
                                context.fillStyle = "rgb(150,75,0)";
                                context.font = fs + "px Icons";
                                context.fillText(character, cxy[0], cxy[1]);
                                context.fillStyle = planet.style[settings.theme].hi;
                                context.font = "12px Arial";
                                context.fillText(data.basestations[x].town, cxy[0] - 30, cxy[1] + 20);
                                if (scale > 2e3 && data.basestations[x].status) {
                                    context.fillText("Filed:" + data.basestations[x].fd, cxy[0] - 30, cxy[1] + 40);
                                    if (data.basestations[x].status == "uncertain") {
                                        context.strokeStyle = "rgba(255,255,0,1.0)"
                                    } else {
                                        context.strokeStyle = "rgba(0,255,0,1.0)"
                                    }
                                    context.beginPath();
                                    context.arc(Math.floor(cxy[0]), Math.floor(cxy[1]), 15, 0, 2 * Math.PI);
                                    context.stroke()
                                }
                            } else {
                                var sz = 3;
                                var t0 = Math.floor(performance.now() / 1e3);
                                context.fillStyle = t0 % 2 == 0 ? "rgb(150,75,0)" : "rgb(255,0,0)";
                                context.fillRect(Math.floor(cxy[0]), Math.floor(cxy[1]), sz, sz)
                            }
                        }
                    }
                }
                if (0) {}
            })
        }
    }
    ;
    planetaryjs.plugins.coverage = function(config) {
        var data = null;
        var setCoverage = function(d) {
            data = d
        };
        var drawCoverage = function(planet, context, now) {};
        return function(planet) {
            planet.plugins.coverage = {
                set: setCoverage,
                draw: drawCoverage
            };
            planet.onDraw(function() {
                var context = planet.context;
                const scale = planet.projection.scale();
                if (data && (!planet.settings || planet.settings.showcov == true)) {
                    context.strokeStyle = "rgba(0,128,0,0.5)";
                    for (var x = 0; x < data.length; x++) {
                        var projection = planet.projection;
                        var geoGenerator = d3.geo.path().projection(projection).context(context);
                        context.beginPath();
                        geoGenerator({
                            type: "Feature",
                            geometry: {
                                type: "MultiLineString",
                                coordinates: data[x].geo[0]
                            }
                        });
                        context.stroke()
                    }
                }
            })
        }
    }
    ;
    planetaryjs.plugins.peeps = function(config) {
        var data = null;
        var setPeeps = function(d) {
            data = d
        };
        var drawPeeps = function(planet, context, now) {};
        return function(planet) {
            planet.plugins.peeps = {
                set: setPeeps,
                draw: drawPeeps
            };
            planet.onDraw(function() {
                var context = planet.context;
                const scale = planet.projection.scale();
                if (data && (planet.settings && planet.settings.showpeeps != "no")) {
                    context.font = "normal 14px Arial";
                    context.textBaseline = "middle";
                    context.textAlign = "center";
                    var projection = planet.projection;
                    var geoGenerator = d3.geo.path().projection(projection).context(context);
                    const mx = planet.canvas.width;
                    const my = planet.canvas.height;
                    const margin = 0;
                    const selected = planet.plugins.pings.getsel(planet).length;
                    for (var x = 0; x < data.length; x++) {
                        var visible = true;
                        if (settings.showpeeps == "using" && !data[x].stats.using)
                            continue;
                        if (settings.showpeeps == "ordered" && !data[x].stats.pre)
                            continue;
                        if (settings.showpeeps == "useorder" && !data[x].stats.pre && !data[x].stats.using)
                            continue;
                        if (settings.showpeeps == "want" && !data[x].stats.want)
                            continue;
                        if (planet.projection_selected == "orthographic") {
                            var geoangle = d3.geo.distance([data[x].c[1], data[x].c[0]], [-planet.projection.rotate()[0], -planet.projection.rotate()[1]]);
                            visible = geoangle > 1.5707963267949 + .4 ? false : true
                        }
                        const cxy = visible ? planet.projection([data[x].c[1], data[x].c[0]]) : [];
                        if (visible && (cxy[0] >= -margin && cxy[1] >= -margin) && (cxy[0] <= mx + margin && cxy[1] <= my + margin)) {
                            context.fillStyle = selected ? "rgba(128,128,128,0.5)" : data[x].color;
                            context.beginPath();
                            geoGenerator({
                                type: "Feature",
                                geometry: {
                                    type: "MultiLineString",
                                    coordinates: data[x].geo[0]
                                }
                            });
                            context.fill();
                            if (scale > 12e3) {
                                context.fillStyle = "rgb(255,255,255)";
                                context.fillText("Want: " + data[x].stats.want, cxy[0], cxy[1] - 40);
                                context.fillText("Pre-Ordered: " + data[x].stats.pre, cxy[0], cxy[1] - 20);
                                context.fillText("Using: " + data[x].stats.using, cxy[0], cxy[1]);
                                if (data[x].stats.desc) {
                                    context.font = "normal 12px Arial";
                                    const lines = data[x].stats.desc.split(":");
                                    if (lines[0])
                                        context.fillText(lines[0], cxy[0], cxy[1] + 20);
                                    if (lines[1])
                                        context.fillText(lines[1], cxy[0], cxy[1] + 40);
                                    context.font = "normal 14px Arial"
                                }
                            } else if (scale > 4e3) {
                                if (data[x].stats.using == 0 && data[x].stats.pre == 0) {
                                    context.fillStyle = "rgb(255,255,255)";
                                    context.fillText(data[x].stats.want, cxy[0], cxy[1])
                                }
                                if (data[x].stats.using) {
                                    context.fillStyle = "rgb(0,0,0)";
                                    context.fillText(data[x].stats.want + "/" + data[x].stats.pre + "/" + data[x].stats.using, cxy[0], cxy[1])
                                }
                                if (!data[x].stats.using && data[x].stats.pre) {
                                    context.fillStyle = "rgb(255,255,255)";
                                    context.fillText(data[x].stats.want + "/" + data[x].stats.pre, cxy[0], cxy[1])
                                }
                            }
                        }
                    }
                }
            })
        }
    }
    ;
    planetaryjs.plugins.intensity = function(config) {
        var data = null;
        var setIntensity = function(d) {
            data = d
        };
        var drawIntensity = function(planet, context, now) {};
        var percentColors = [{
            pct: 0,
            color: {
                r: 255,
                g: 0,
                b: 0
            }
        }, {
            pct: .9,
            color: {
                r: 255,
                g: 255,
                b: 0
            }
        }, {
            pct: 1,
            color: {
                r: 0,
                g: 255,
                b: 0
            }
        }];
        var getColorForPercentage = function(pct) {
            for (var i = 1; i < percentColors.length - 1; i++) {
                if (pct < percentColors[i].pct) {
                    break
                }
            }
            var lower = percentColors[i - 1];
            var upper = percentColors[i];
            var range = upper.pct - lower.pct;
            var rangePct = (pct - lower.pct) / range;
            var pctLower = 1 - rangePct;
            var pctUpper = rangePct;
            var color = {
                r: Math.floor(lower.color.r * pctLower + upper.color.r * pctUpper),
                g: Math.floor(lower.color.g * pctLower + upper.color.g * pctUpper),
                b: Math.floor(lower.color.b * pctLower + upper.color.b * pctUpper)
            };
            return "rgba(" + [color.r, color.g, color.b].join(",") + ",0.5)"
        };
        return function(planet) {
            planet.plugins.intensity = {
                set: setIntensity,
                draw: drawIntensity
            };
            planet.onDraw(function() {
                var context = planet.context;
                const scale = planet.projection.scale();
                if (data && (planet.settings && planet.settings.showintensity == true)) {
                    context.font = "normal 18px Arial";
                    for (var x = 0; x < data.length; x++) {
                        context.fillStyle = getColorForPercentage(data[x].coverage);
                        var projection = planet.projection;
                        var geoGenerator = d3.geo.path().projection(projection).context(context);
                        var geoangle = d3.geo.distance([data[x].c[1], data[x].c[0]], [-planet.projection.rotate()[0], -planet.projection.rotate()[1]]);
                        var visible = geoangle > 1.5707963267949 + .4 ? false : true;
                        if (visible) {
                            context.beginPath();
                            geoGenerator({
                                type: "Feature",
                                geometry: {
                                    type: "MultiLineString",
                                    coordinates: data[x].geo[0]
                                }
                            });
                            context.fill();
                            if (scale > 2e3) {
                                const cxy = planet.projection([data[x].c[1], data[x].c[0]]);
                                context.fillStyle = "rgb(255,255,255)";
                                context.fillText(Math.floor(data[x].coverage * 100) + "% link", cxy[0] - 30, cxy[1])
                            }
                        }
                    }
                }
            })
        }
    }
    ;
    planetaryjs.plugins.myloc = function(config) {
        var myloc = [];
        var inrange = null;
        var setLoc = function(x) {
            myloc = x
        };
        var drawLoc = function(planet, context, now) {};
        var gospot = function(planet, lng, lat) {
            if (planet.projection_selected == "orthographic") {
                var rotation = planet.projection.rotate();
                rotation[0] = -lng;
                rotation[1] = -lat;
                rotation[2] = 0;
                planet.projection.scale(2e3);
                planet.projection.rotate(rotation);
                planet.interacted = new Date
            }
        };
        var gohome = function(planet) {
            if (planet.projection_selected == "orthographic") {
                var lat = planet.settings.myloc[0];
                var lng = planet.settings.myloc[1];
                var rotation = planet.projection.rotate();
                rotation[0] = -lng;
                rotation[1] = -lat;
                rotation[2] = 0;
                planet.projection.scale(1600);
                planet.projection.rotate(rotation);
                planet.interacted = new Date
            }
        };
        var inrange = function(i) {
            inrange = i
        };
        return function(planet) {
            planet.plugins.myloc = {
                set: setLoc,
                draw: drawLoc,
                gohome: gohome,
                gospot: gospot,
                inrange: inrange
            };
            planet.onDraw(function() {
                if (planet.settings && planet.settings.scopemode) {
                    myloc = planet.settings.myloc;
                    var lat = planet.settings.myloc[0];
                    var lng = planet.settings.myloc[1];
                    var rotation = planet.projection.rotate();
                    rotation[0] = -lng;
                    rotation[1] = -lat;
                    rotation[2] = ppp.device_heading ? ppp.device_heading.dir : 0;
                    planet.projection.scale(1600);
                    planet.projection.rotate(rotation)
                }
                if (myloc.length) {
                    var geoangle = d3.geo.distance([myloc[1], myloc[0]], [-planet.projection.rotate()[0], -planet.projection.rotate()[1]]);
                    planet.home_visible = geoangle > 1.5707963267949 ? false : true;
                    var mx = planet.canvas.width;
                    var my = planet.canvas.height;
                    var margin = 0;
                    var cxy = planet.projection([myloc[1], myloc[0]]);
                    if (planet.home_visible && (cxy[0] >= -margin && cxy[1] >= -margin) && (cxy[0] <= mx + margin && cxy[1] <= my + margin)) {
                        planet.home_visible = cxy
                    } else {
                        planet.home_visible = null
                    }
                    if (planet.settings && planet.settings.scopemode) {
                        var context = planet.context;
                        if (planet.home_visible == null) {
                            console.log("error ", cxy)
                        }
                        context.strokeStyle = "rgba(255,0,0,0.5)";
                        context.lineWidth = 2;
                        for (var radius = 200; radius >= 50; radius -= 50) {
                            context.beginPath();
                            context.arc(Math.floor(cxy[0]), Math.floor(cxy[1]), radius, 0, 2 * Math.PI);
                            context.stroke()
                        }
                    }
                    if (planet.home_visible) {
                        var context = planet.context;
                        const scale = planet.projection.scale();
                        var circle = d3.geo.circle().origin([myloc[1], myloc[0]]).angle(scale > 1200 ? .1 : .2)();
                        context.beginPath();
                        context.fillStyle = "rgba(128,255,128,0.5)";
                        planet.path.context(context)(circle);
                        context.fill();
                        if (planet.projection.scale() > 1600 && !isNaN(inrange)) {
                            context.font = "normal 14px Arial";
                            context.fillStyle = "rgb(0,0,0)";
                            context.textBaseline = "middle";
                            context.textAlign = "center";
                            context.fillText(inrange, cxy[0], cxy[1])
                        }
                    }
                }
            })
        }
    }
    ;
    planetaryjs.plugins.pings = function(config) {
        var pings = [];
        var server_offset;
        var pings_stamp;
        var one_selected = null;
        var visdata = new Array;
        var callcounters = {
            a: 0,
            b: 0
        };
        var launches = null;
        config = config || {};
        var visData = function() {
            return visdata
        };
        var addLaunches = function(d) {
            launches = d
        };
        var p2l = function(p) {
            var l = parseInt(p.name.split("-")[0]);
            if (launches) {
                for (var x = 0; x < launches.length; x++) {
                    if (parseInt(launches[x].id) == l)
                        return launches[x]
                }
            }
            return null
        };
        var findPing = function(now, lng, lat, xy) {
            var alive = now / 1e3 - pings_stamp + offset;
            var dist = alive * 7e3;
            var mind = 9999999999;
            var near = null;
            for (var i = 0; i < pings.length; i++) {
                var ping = pings[i];
                if (Geodesic && 0) {
                    var l = geod.InverseLine(ping.lat, ping.lng, ping.lat2, ping.long2), n = Math.ceil(l.s13 / dist), i, s;
                    s = Math.min(dist, l.s13);
                    var r = l.Position(s, Geodesic.STANDARD | Geodesic.LONG_UNROLL);
                    var thislat = r.lat2.toFixed(5);
                    var thislng = r.lon2.toFixed(5);
                    var dlat = thislat - lat;
                    var dlng = thislng - lng;
                    var d = dlat * dlat + dlng * dlng;
                    if (dlat && dlng && d < mind && d < 3.5) {
                        mind = d;
                        near = i
                    }
                }
                if (ping.cxy && ping.visible) {
                    var dist = Math.pow(xy[0] - ping.cxy[0], 2) + Math.pow(xy[1] - ping.cxy[1], 2);
                    if (dist < 100 && dist < mind) {
                        mind = dist;
                        near = i
                    }
                }
            }
            return near
        };
        var unselPing = function(x, planet) {
            one_selected = null;
            for (var y = 0; y < pings.length; y++) {
                pings[y].selected = false;
                pings[y].associated = false
            }
        };
        var getselPing = function(planet) {
            var sellist = [];
            for (var y = 0; y < pings.length; y++)
                if (pings[y].selected)
                    sellist.push(pings[y].id);
            return sellist
        };
        var selPing = function(x, planet, nomove) {
            if (pings.length) {
                var raan_min = parseFloat(pings[x].raan) - 1.5;
                var raan_max = parseFloat(pings[x].raan) + 1.5;
                one_selected = x;
                for (var y = 0; y < pings.length; y++) {
                    pings[y].selected = false;
                    pings[y].associated = false;
                    if (parseFloat(pings[y].raan) >= raan_min && parseFloat(pings[y].raan) <= raan_max) {
                        pings[y].associated = true
                    }
                }
                pings[x].selected = true;
                if (!nomove) {
                    var lng = pings[x].lng1;
                    var lat = pings[x].lat1;
                    var rotation = planet.projection.rotate();
                    rotation[0] = -lng;
                    if (planet.projection_selected == "orthographic") {
                        rotation[1] = -lat
                    }
                    rotation[2] = 0;
                    planet.projection.rotate(rotation)
                }
                planet.interacted = new Date
            }
        };
        var wipePing = function() {
            pings = []
        };
        var debugPing = function() {
            return {
                pings: pings,
                callcounters: callcounters,
                server_offset: server_offset,
                pings_stamp: pings_stamp
            }
        };
        var offsets = function(offset, stamp) {
            server_offset = offset;
            pings_stamp = stamp
        };
        function l2sat(x) {
            var id = launches[x].id;
            const r = new RegExp("^" + id + "-","i");
            for (var x = 0; x < pings.length; x++) {
                if (pings[x].name.match(r)) {
                    return {
                        id: pings[x].id,
                        ll: [pings[x].lat1, pings[x].lng1]
                    }
                }
            }
            return null
        }
        var isearch = function(str) {
            var m = new Array;
            const r = new RegExp(str,"i");
            for (var x = 0; x < pings.length; x++) {
                if ((pings[x].id + "").match(r) || pings[x].oname.match(r)) {
                    m.push({
                        typ: "satellite",
                        id: pings[x].id,
                        ll: [pings[x].lat1, pings[x].lng1],
                        m: (pings[x].id + "").match(r) ? pings[x].id : pings[x].oname
                    })
                }
            }
            if (launches)
                for (x = 0; x < launches.length; x++) {
                    if ("mission".match(r) || ("Mission " + launches[x].mission).match(r)) {
                        var f = l2sat(x);
                        if (f)
                            m.push({
                                typ: "launch",
                                id: f.id,
                                ll: f.ll,
                                m: "Mission " + launches[x].mission
                            })
                    }
                    if ("launch".match(r) || ("Launch " + launches[x].utc).match(r)) {
                        var f = l2sat(x);
                        if (f)
                            m.push({
                                typ: "launch",
                                id: f.id,
                                ll: f.ll,
                                m: "Launch " + launches[x].utc
                            })
                    }
                    if (("Launch #" + launches[x].id).match(r)) {
                        var f = l2sat(x);
                        if (x == 1) {
                            console.error(r, "matches", launches[x].no, "result", f)
                        }
                        if (f)
                            m.push({
                                typ: "launch",
                                id: f.id,
                                ll: f.ll,
                                m: "Launch #" + launches[x].id
                            })
                    }
                    if (x == launches.length - 1) {
                        if ("latest launch".match(r)) {
                            var f = l2sat(x);
                            if (f)
                                m.push({
                                    typ: "launch",
                                    id: f.id,
                                    ll: f.ll,
                                    m: "Latest Launch"
                                })
                        }
                    }
                }
            return m
        };
        var addPing = function(lng, lat, options) {
            options = options || {};
            options.color = options.color || config.color || "white";
            options.angle = options.angle || config.angle || 5;
            options.ttl = options.ttl || config.ttl || 2e3;
            var ping = {
                time: new Date,
                options: options
            };
            ping.lat2 = options.lat2;
            ping.long2 = options.long2;
            ping.aged = options.aged;
            ping.alt = options.alt;
            ping.alt2 = options.alt2;
            ping.id = options.id;
            ping.name = options.name;
            ping.raan = options.raan;
            ping.oname = options.oname;
            ping.lng = lng;
            ping.lat = lat;
            if (!Geodesic && typeof GeographicLib != "undefined") {
                Geodesic = GeographicLib.Geodesic,
                DMS = GeographicLib.DMS,
                geod = Geodesic.WGS84
            }
            if (Geodesic) {
                ping.dd = geod.Inverse(ping.lat, ping.lng, ping.lat2, ping.long2).s12;
                ping.l = geod.InverseLine(ping.lat, ping.lng, ping.lat2, ping.long2)
            }
            pings.push(ping)
        };
        var drawPings = function(planet, context, now) {
            if (callcounters.a == 0)
                window.dispatchEvent(new Event("resize"));
            callcounters.a++;
            var inrange = 0;
            if (planet.settings && planet.settings.scopemode)
                planet.scope = new Array;
            var alive = now / 1e3 - pings_stamp + offset;
            if (isNaN(alive))
                return;
            for (var i = 0; i < pings.length; i++)
                inrange += drawPing(planet, context, now, pings[i], alive / 300);
            if (pings.length)
                planet.plugins.myloc.inrange(inrange)
        };
        var drawPing = function(planet, context, now, ping, alive) {
            var throttle = planet.settings && planet.settings.scopemode ? .02 : .2;
            var inrange = 0;
            if (ping.alt == 0 || !ping.dd || !Geodesic)
                return 0;
            if (ping.visible === false && Math.random() > throttle) {
                return 0
            }
            ping.visible = false;
            var lat, lng, dist;
            dist = ping.dd * alive;
            const rr = ping.l.Position(dist, Geodesic.STANDARD | Geodesic.LONG_UNROLL);
            lat = rr.lat2;
            lng = rr.lon2;
            ping.lat1 = lat;
            ping.lng1 = lng;
            ping.xalt = (ping.alt + (ping.alt2 - ping.alt) * alive).toFixed(1);
            var visible = true;
            var distant = false;
            if (ping.alt > 2e3) {
                distant = true
            }
            var goflat_distance = distant ? 600 : 1500;
            const scale = planet.projection.scale();
            if (planet.projection_selected == "orthographic") {
                var horizon = .4;
                if (ping.alt > 2e3) {
                    horizon = .5 * Math.PI / 2;
                    if (ping.alt > 1e4)
                        horizon = .78 * Math.PI / 2;
                    if (ping.alt > 18e3)
                        horizon = .83 * Math.PI / 2;
                    if (ping.alt > 35e3)
                        horizon = .9 * Math.PI / 2
                }
                if (scale > goflat_distance)
                    horizon = 0;
                var geoangle = d3.geo.distance([lng, lat], [-planet.projection.rotate()[0], -planet.projection.rotate()[1]]);
                visible = geoangle > Math.PI / 2 + horizon ? false : true
            }
            if (visible) {
                if (planet.projection_selected != "mercator" && scale < goflat_distance) {
                    var ss = scale * (1 + ping.alt / 6371);
                    planet.projection.scale(ss)
                }
                var cxy = planet.projection([lng, lat]);
                var mx = planet.canvas.width;
                var my = planet.canvas.height;
                var margin = 150;
                ping.cxy = cxy;
                if (distant || cxy[0] > -margin && cxy[1] > -margin && (cxy[0] < mx + margin && cxy[1] < my + margin)) {
                    ping.visible = true;
                    if (ping.selected || ping.associated) {
                        var geoGenerator = d3.geo.path().projection(planet.projection).context(context);
                        context.beginPath();
                        context.strokeStyle = "red";
                        geoGenerator({
                            type: "Feature",
                            geometry: {
                                type: "LineString",
                                coordinates: [[ping.lng, ping.lat], [ping.long2, ping.lat2]]
                            }
                        });
                        context.stroke()
                    }
                    if ((scale > goflat_distance || distant) && planet.home_visible) {
                        var r = d3.geo.distance([lng, lat], [settings.myloc[1], settings.myloc[0]]);
                        var d = 6371 * r;
                        var seen = null;
                        if (distant || d <= 1e3) {
                            seen = inclusion(visdata, ping.oname, ping.id, d.toFixed(2), [settings.myloc[1], settings.myloc[0]], [lng, lat], ping.alt);
                            if (seen[3]) {
                                if (scale > goflat_distance) {
                                    var geoGenerator = d3.geo.path().projection(planet.projection).context(context);
                                    context.beginPath();
                                    context.strokeStyle = "red";
                                    geoGenerator({
                                        type: "Feature",
                                        geometry: {
                                            type: "LineString",
                                            coordinates: [[settings.myloc[1], settings.myloc[0]], [lng, lat]]
                                        }
                                    });
                                    context.stroke()
                                } else {
                                    var ctx = planet.canvas.getContext("2d");
                                    ctx.beginPath();
                                    ctx.strokeStyle = "red";
                                    ctx.moveTo(cxy[0], cxy[1]);
                                    ctx.lineTo(planet.home_visible[0], planet.home_visible[1]);
                                    ctx.stroke()
                                }
                                inrange = 1
                            }
                            if (planet.scope) {
                                const past_position = ping.dd * (alive - .05);
                                const r = ping.l.Position(past_position, Geodesic.STANDARD | Geodesic.LONG_UNROLL);
                                const o = azelev([settings.myloc[1], settings.myloc[0]], [r.lon2, r.lat2], ping.alt);
                                planet.scope.push({
                                    norad: ping.id,
                                    vector: seen,
                                    vector2: o,
                                    alt: ping.alt
                                })
                            }
                        }
                    }
                    if (ping.selected || ping.associated) {
                        if (ping.selected)
                            context.fillStyle = planet.style[settings.theme].green;
                        else
                            context.fillStyle = planet.style[settings.theme].yel
                    } else {
                        if (one_selected) {
                            context.fillStyle = planet.style[settings.theme].dim
                        } else {
                            if (ping.options.illum || planet.settings && planet.settings.redwhite === false) {
                                context.fillStyle = planet.style[settings.theme].hi
                            } else {
                                context.fillStyle = planet.style[settings.theme].red
                            }
                        }
                    }
                    const iss = ping.id == 25544 || ping.id == 48274;
                    if (iss) {
                        var fs = Math.floor(scale / 200 * 4);
                        if (fs < 4)
                            fs = 4;
                        if (fs > 20)
                            fs = 20;
                        fs = 10;
                        const character = "";
                        context.fillStyle = "rgb(0,255,0)";
                        context.font = fs + "px Icons";
                        context.fillText(character, cxy[0] - 2, cxy[1] + 3)
                    } else {
                        if (distant) {
                            context.beginPath();
                            context.arc(Math.floor(cxy[0]), Math.floor(cxy[1]), 2, 0, 2 * Math.PI);
                            context.fill()
                        } else {
                            if (scale < 200) {
                                context.fillRect(Math.floor(cxy[0]), Math.floor(cxy[1]), 1, 1)
                            } else {
                                context.beginPath();
                                context.arc(Math.floor(cxy[0]), Math.floor(cxy[1]), scale / 300 > 3 ? 3 : scale / 300, 0, 2 * Math.PI);
                                context.fill()
                            }
                        }
                    }
                    if (distant) {
                        if (scale > 300) {
                            context.font = "12px Arial";
                            context.textBaseline = "middle";
                            context.textAlign = "center";
                            context.fillText(ping.oname, cxy[0], cxy[1] + 12)
                        }
                    }
                    if (scale > 1e3) {
                        context.font = "12px Arial";
                        context.textBaseline = "middle";
                        context.textAlign = "center";
                        context.fillText(ping.xalt + "km", cxy[0], cxy[1] - 8);
                        var lastpx;
                        if (scale > 1599) {
                            context.fillText(ping.oname, cxy[0], cxy[1] + 12);
                            lastpx = 12
                        } else {
                            lastpx = 12
                        }
                        if (seen && scale > goflat_distance) {
                            context.fillText("elev:" + seen[0].toFixed(1) + "°", cxy[0], cxy[1] + lastpx + 12);
                            context.fillText("az:" + seen[1].toFixed(1) + "°", cxy[0], cxy[1] + lastpx + 24)
                        }
                        if (scale > 3200 && 0) {
                            var a = satfixes[ping.id];
                            if (a) {
                                var o = a[0].epoch;
                                for (var i = 0; i < a.length; i++) {
                                    var x = Math.floor((a[i].epoch - o) * 4);
                                    var y = Math.floor(a[i].alt - 250) / 10;
                                    context.fillStyle = "rgb(255,255,255,0.5)";
                                    context.fillRect(cxy[0] - 50 + x, cxy[1] + 50, 2, -y)
                                }
                                context.fillStyle = "rgb(255,255,255)";
                                context.fillText("altitude history", cxy[0] - 40, cxy[1] + 65)
                            } else {
                                context.fillStyle = "rgb(255,255,255)";
                                context.fillText("no alt history", cxy[0] - 40, cxy[1] + 65)
                            }
                        }
                    }
                    if (scale > 190 && (!planet.settings || planet.settings.showrings)) {
                        if (!one_selected || ping.associated || ping.selected) {
                            var radius = ping.alt / 520 * 4;
                            planet.projection.scale(scale);
                            context.lineWidth = 1;
                            var circle = d3.geo.circle().origin([lng, lat]).angle(radius)();
                            context.beginPath();
                            planet.path.context(context)(circle);
                            context.stroke()
                        }
                    }
                }
                planet.projection.scale(scale)
            }
            return inrange
        };
        return function(planet) {
            planet.plugins.pings = {
                add: addPing,
                addlaunches: addLaunches,
                wipe: wipePing,
                sel: selPing,
                unsel: unselPing,
                getsel: getselPing,
                find: findPing,
                p2l: p2l,
                isearch: isearch,
                visdata: visData,
                offsets: offsets,
                debugping: debugPing
            };
            planet.onDraw(function() {
                callcounters.b++;
                var now = new Date;
                planet.withSavedContext(function(context) {
                    drawPings(planet, context, now)
                })
            })
        }
    }
    ;
    planetaryjs.plugins.zoom = function(options) {
        options = options || {};
        var noop = function() {};
        var onZoomStart = function() {};
        var onZoomEnd = options.onZoomEnd || noop;
        var onZoom = options.onZoom || noop;
        var afterZoom = options.afterZoom || noop;
        var startScale = options.initialScale;
        var scaleExtent = options.scaleExtent || [50, 2e3];
        var lastMousePos;
        var mousePos;
        return function(planet) {
            planet.onInit(function() {
                var zoom = d3.behavior.zoom().scaleExtent(scaleExtent);
                var tx = 0
                  , ty = 0;
                if (startScale !== null && startScale !== undefined) {
                    zoom.scale(startScale)
                } else {
                    zoom.scale(planet.projection.scale())
                }
                d3.select("canvas").on("touchmove", function() {
                    d3.event.preventDefault();
                    var a = d3.touches(this);
                    if (a.length == 2) {
                        tx = (a[0][0] + a[1][0]) / 2;
                        ty = (a[0][1] + a[1][1]) / 2
                    }
                });
                zoom.on("zoomstart", function(e) {
                    var pz = planet.projection.scale();
                    zoom.scale(pz);
                    onZoomStart.bind(planet)
                }).on("zoomend", onZoomEnd.bind(planet)).on("zoom", function(e) {
                    var bz = planet.projection.scale();
                    var x, y;
                    if (tx && ty) {
                        x = tx;
                        y = ty
                    } else {
                        x = d3.mouse(this)[0];
                        y = d3.mouse(this)[1]
                    }
                    var p = planet.projection.invert([x, y]);
                    planet.stopped = false;
                    onZoom.call(planet);
                    planet.projection.scale(d3.event.scale);
                    afterZoom.call(planet);
                    if (planet.projection_selected == "mercator") {
                        var cxy1 = planet.projection(p);
                        var dx = cxy1[0] - x;
                        var dy = cxy1[1] - y;
                        var o = planet.projection.translate();
                        planet.projection.translate([o[0] - dx, o[1] - dy])
                    }
                    planet.interacted = new Date
                });
                d3.select(planet.canvas).call(zoom)
            })
        }
    }
    ;
    planetaryjs.plugins.drag = function(options) {
        options = options || {};
        var noop = function() {};
        var onDragStart = options.onDragStart || noop;
        var onDragEnd = options.onDragEnd || noop;
        var onDrag = options.onDrag || noop;
        var afterDrag = options.afterDrag || noop;
        return function(planet) {
            planet.onInit(function() {
                var drag = d3.behavior.drag().on("dragstart", onDragStart.bind(planet)).on("dragend", onDragEnd.bind(planet)).on("drag", function() {
                    planet.stopped = false;
                    planet.interacted = new Date;
                    onDrag.call(planet);
                    var dx = d3.event.dx;
                    var dy = d3.event.dy;
                    var rotation = planet.projection.rotate();
                    var radius = planet.projection.scale();
                    var scale = d3.scale.linear().domain([-1 * radius, radius]).range([-90, 90]);
                    var degX = scale(dx * .8);
                    var degY = scale(dy * .65);
                    rotation[0] += degX;
                    rotation[1] -= degY;
                    if (!planet.momentum_x)
                        planet.momentum_x = 0;
                    if (!planet.momentum_y)
                        planet.momentum_y = 0;
                    planet.momentum_x = planet.momentum_x * .8 + degX * .2;
                    planet.momentum_y = planet.momentum_y * .8 + degY * .2;
                    if (rotation[1] > 90)
                        rotation[1] = 90;
                    if (rotation[1] < -90)
                        rotation[1] = -90;
                    if (rotation[0] >= 180)
                        rotation[0] -= 360;
                    if (planet.projection_selected != "mercator")
                        planet.projection.rotate(rotation);
                    if (planet.projection_selected == "mercator") {
                        var w = planet.canvas.width;
                        var h = planet.canvas.height;
                        var o = planet.projection.translate();
                        planet.projection.translate([o[0] + d3.event.dx, o[1] + d3.event.dy]);
                        planet.momentum_x = planet.momentum_x * .8 + d3.event.dx * .8;
                        planet.momentum_y = planet.momentum_y * .8 + d3.event.dy * .8
                    }
                    afterDrag.call(planet)
                });
                d3.select(planet.canvas).call(drag)
            })
        }
    }
    ;
    return planetaryjs
});
